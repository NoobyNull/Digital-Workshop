# Digital Workshop â€“ GitLab CI configuration for Windows EXE builds

workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "web"'
    - when: never

stages:
  - build
  - cleanup

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  RUN_TESTS: "false"
  WINDOWS_PYTHON_VERSION: "3.11.6"
  WINDOWS_RUNNER_TAGS: "windows,digital-workshop,pyinstaller"
  DIST_DIR: "dist"
  EXE_NAME: "Digital Workshop"
  PYTHONUTF8: "1"
  PYTHONIOENCODING: "utf-8"
  PYTHONUNBUFFERED: "1"
  REVISION_TAG_PREFIX: "revision-"
  REVISION_OVERRIDE: ""

cache:
  key: "$CI_COMMIT_REF_SLUG-windows"
  paths:
    - .cache/pip/

build_windows_exe:
  stage: build
  tags:
    - windows
    - digital-workshop
    - pyinstaller
  timeout: 2h
  script: |
    Set-StrictMode -Version Latest
    $ErrorActionPreference = "Stop"
    $ProgressPreference = "SilentlyContinue"
    chcp 65001 | Out-Null

    function Ensure-Python {
      param([string]$Version)
      if (Get-Command python -ErrorAction SilentlyContinue) {
        return
      }
      if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
        throw "Python is not installed and Chocolatey is unavailable on this runner."
      }
      Write-Host "Installing Python $Version via Chocolatey..."
      choco install python --version $Version -y --no-progress
      $pythonInstall = Get-ChildItem -Directory "C:\Python*" | Sort-Object LastWriteTime -Descending | Select-Object -First 1
      if ($pythonInstall) {
        $env:Path = "$($pythonInstall.FullName);$($pythonInstall.FullName)\Scripts;$env:Path"
      }
    }

    function Ensure-File {
      param([string]$Path)
      if (-not (Test-Path $Path)) {
        Set-Content -Path $Path -Value "{}" -Encoding utf8
      }
    }

    function Get-RevisionInfo {
      $prefix = if ($Env:REVISION_TAG_PREFIX) { $Env:REVISION_TAG_PREFIX } else { "revision-" }
      git fetch --tags --force | Out-Null

      if ($Env:REVISION_OVERRIDE) {
        if ($Env:REVISION_OVERRIDE -notmatch '^\d+$') {
          throw "REVISION_OVERRIDE must be a positive integer."
        }
        $override = [int]$Env:REVISION_OVERRIDE
        if ($override -le 0) {
          throw "REVISION_OVERRIDE must be greater than zero."
        }
        if (git tag -l "$prefix$override") {
          throw "Revision tag $prefix$override already exists."
        }
        return [pscustomobject]@{ Number = $override; Tag = "$prefix$override" }
      }

      $tags = git tag -l "$prefix*"
      if (-not $tags) { return [pscustomobject]@{ Number = 1; Tag = "$prefix1" } }

      $numbers = @()
      foreach ($tag in $tags) {
        if ($tag -match "^$([Regex]::Escape($prefix))(\d+)$") {
          $numbers += [int]$matches[1]
        }
      }
      $next = if ($numbers) { ([int]($numbers | Sort-Object | Select-Object -Last 1)) + 1 } else { 1 }
      return [pscustomobject]@{ Number = $next; Tag = "$prefix$next" }
    }

    Ensure-Python -Version $Env:WINDOWS_PYTHON_VERSION
    python --version
    python -m pip --version

    Write-Host "== Installing dependencies =="
    python -m pip install --upgrade pip setuptools wheel
    python -m pip install -r requirements.txt -r requirements-dev.txt
    python -m pip install openai anthropic google-generativeai zhipuai python-dotenv requests qdarkstyle
    python -m pip install bandit safety semgrep

    Write-Host "== Running security scans =="
    python -m safety check --json --output safety-report.json
    python -m bandit -r src/ -f json -o bandit-report.json
    semgrep --config=auto --json --output=semgrep-report.json src/

    Write-Host "== Applying automated security fixes =="
    python scripts/auto_security_fix.py --project-root .
    Ensure-File -Path "security-fixes.json"

    if ("$Env:RUN_TESTS" -eq "true") {
      Write-Host "== Running pytest suite =="
      python -m pytest --junitxml junit.xml
    }

    Write-Host "== Determining revision number =="
    $revisionInfo = Get-RevisionInfo
    $revision = $revisionInfo.Number
    $revisionTag = $revisionInfo.Tag
    Write-Host "Revision: $revisionTag"

    Write-Host "== Building Windows executable via PyInstaller =="
    python build_exe.py

    $distDir = if ($Env:DIST_DIR) { $Env:DIST_DIR } else { "dist" }
    $exeBaseName = if ($Env:EXE_NAME) { $Env:EXE_NAME } else { "Digital Workshop" }
    $exePath = Join-Path $distDir "$exeBaseName.exe"
    if (-not (Test-Path $exePath)) { Write-Error "EXE not found at $exePath" }

    $versionedName = "$exeBaseName.$revision.exe"
    $versionedExePath = Join-Path $distDir $versionedName
    Rename-Item -Path $exePath -NewName $versionedName -Force

    $latestExePath = Join-Path $distDir "$exeBaseName.latest.exe"
    Copy-Item -Path $versionedExePath -Destination $latestExePath -Force

    python scripts/generate_changelog.py --build-number $revision --output (Join-Path $distDir "changes-$revision.txt")

    $infoPath = Join-Path $distDir "build-info.txt"
    Set-Content -Path $infoPath -Value "Revision: $revision" -Encoding utf8
    Add-Content -Path $infoPath -Value "Commit: $Env:CI_COMMIT_SHA" -Encoding utf8
    Add-Content -Path $infoPath -Value "Pipeline: $Env:CI_PIPELINE_URL" -Encoding utf8
    Add-Content -Path $infoPath -Value "Branch: $Env:CI_COMMIT_REF_NAME" -Encoding utf8
    Add-Content -Path $infoPath -Value "Runner: $Env:CI_RUNNER_DESCRIPTION" -Encoding utf8
    Add-Content -Path $infoPath -Value "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')" -Encoding utf8

    $releaseInfoPath = Join-Path $distDir "release-$revision.json"
    $releaseInfo = @{
      "revision" = $revision
      "commitSha" = $Env:CI_COMMIT_SHA
      "commitMessage" = "$(git log -1 --pretty=%s)"
      "commitAuthor" = "$(git log -1 --pretty=%an)"
      "branch" = $Env:CI_COMMIT_REF_NAME
      "pipelineUrl" = $Env:CI_PIPELINE_URL
      "timestamp" = $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
      "changesFile" = "changes-$revision.txt"
    }
    $releaseInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $releaseInfoPath -Encoding utf8

    $hash = Get-FileHash -Algorithm SHA256 -Path $versionedExePath
    $hashLine = "{0}  {1}" -f $hash.Hash, (Split-Path -Leaf $hash.Path)
    Set-Content -Path (Join-Path $distDir "sha256.txt") -Value $hashLine -Encoding utf8

    $revisionRoot = Join-Path $distDir "revisions"
    $revisionDir = Join-Path $revisionRoot $revisionTag
    New-Item -ItemType Directory -Force -Path $revisionDir | Out-Null

    $zipPath = Join-Path $distDir "$exeBaseName.$revision.zip"
    if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
    Compress-Archive -Path (Join-Path $distDir "*") -DestinationPath $zipPath -Force

    Copy-Item -Path $versionedExePath -Destination (Join-Path $revisionDir $versionedName) -Force
    Copy-Item -Path $latestExePath -Destination (Join-Path $revisionDir "$exeBaseName.latest.exe") -Force
    Copy-Item -Path $zipPath -Destination (Join-Path $revisionDir (Split-Path -Leaf $zipPath)) -Force
    Copy-Item -Path (Join-Path $distDir "changes-$revision.txt") -Destination (Join-Path $revisionDir "changes-$revision.txt") -Force
    Copy-Item -Path $infoPath -Destination (Join-Path $revisionDir "build-info.txt") -Force
    Copy-Item -Path $releaseInfoPath -Destination (Join-Path $revisionDir "release-$revision.json") -Force
    Copy-Item -Path (Join-Path $distDir "sha256.txt") -Destination (Join-Path $revisionDir "sha256.txt") -Force

    $manifestPath = Join-Path $revisionRoot "manifest.json"
    $revisionPattern = "^$([Regex]::Escape($Env:REVISION_TAG_PREFIX))(\d+)$"
    $manifestEntries = @()
    $existingTags = git tag -l "$($Env:REVISION_TAG_PREFIX)*"
    foreach ($tag in $existingTags) {
      if ($tag -match $revisionPattern) {
        $number = [int]$matches[1]
        $sha = (git rev-list -n 1 $tag).Trim()
        $entry = [pscustomobject]@{
          revision = $number
          tag = $tag
          commit = $sha
        }
        if ($number -eq $revision) {
          continue
        }
        $manifestEntries += $entry
      }
    }
    $manifestEntries += [pscustomobject]@{
      revision = $revision
      tag = $revisionTag
      exe = $versionedName
      zip = (Split-Path -Leaf $zipPath)
      commit = $Env:CI_COMMIT_SHA
      pipeline = $Env:CI_PIPELINE_URL
      timestamp = (Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
    }
    ($manifestEntries | Sort-Object revision) | ConvertTo-Json -Depth 4 | Out-File -FilePath $manifestPath -Encoding utf8

    git config user.email "ci@digital-workshop.local"
    git config user.name "CI Builder"
    git fetch --tags --force
    git tag -f $revisionTag -m "Revision $revision"

    if ($Env:CI_JOB_TOKEN -and $Env:CI_SERVER_URL -and $Env:CI_PROJECT_PATH) {
      $remoteUri = New-Object System.UriBuilder("$($Env:CI_SERVER_URL.TrimEnd('/'))/$($Env:CI_PROJECT_PATH).git")
      $remoteUri.UserName = "gitlab-ci-token"
      $remoteUri.Password = $Env:CI_JOB_TOKEN
      git remote set-url origin $remoteUri.Uri.AbsoluteUri
    }

    git push origin $revisionTag 2>$null || Write-Host "Tag push failed (may already exist)"

  artifacts:
    name: "digital-workshop-revision-$CI_PIPELINE_ID"
    when: always
    expire_in: never
    paths:
      - dist/
      - safety-report.json
      - bandit-report.json
      - semgrep-report.json
      - security-fixes.json
    reports:
      junit: junit.xml
      sast: bandit-report.json
      dependency_scanning: safety-report.json
      secret_detection: semgrep-report.json

cleanup_pipeline:
  stage: cleanup
  tags:
    - windows
    - digital-workshop
    - pyinstaller
  when: always
  allow_failure: true
  script: |
    $status = $Env:CI_PIPELINE_STATUS
    if ($status -eq "success") {
      Write-Host "Pipeline succeeded; nothing to delete."
      exit 0
    }

    if (-not $Env:PIPELINE_DELETE_TOKEN) {
      Write-Warning "PIPELINE_DELETE_TOKEN not set; cannot delete non-successful pipeline."
      exit 0
    }

    $uri = "$Env:CI_API_V4_URL/projects/$($Env:CI_PROJECT_ID)/pipelines/$($Env:CI_PIPELINE_ID)"
    $headers = @{ "PRIVATE-TOKEN" = $Env:PIPELINE_DELETE_TOKEN }
    try {
      Invoke-RestMethod -Method Delete -Uri $uri -Headers $headers -TimeoutSec 30
      Write-Host "Deleted pipeline $($Env:CI_PIPELINE_ID) with status '$status'."
    } catch {
      Write-Warning "Failed to delete pipeline $($Env:CI_PIPELINE_ID): $_"
    }
  rules:
    - if: '$CI_PIPELINE_SOURCE'
