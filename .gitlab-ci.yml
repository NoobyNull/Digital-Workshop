stages:
  - build

variables:
  # Cache directory for pip downloads
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  # Use GitLab's per-project sequential pipeline IID as our build number
  BUILD_NUMBER: "$CI_PIPELINE_IID"
  # Controls whether tests are run before building the EXE ("true" / "false")
  RUN_TESTS: "false"

cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - .cache/pip/

build_windows_exe:
  stage: build
  tags:
    - windows
  script: |
      $ErrorActionPreference = "Stop"

      python --version

      # Install core and dev dependencies
      python -m pip install --upgrade pip
      python -m pip install -r requirements.txt -r requirements-dev.txt

      # Install optional AI/utility dependencies that are used but not listed
      # explicitly in requirements.txt (needed for PyInstaller analysis)
      python -m pip install openai anthropic google-generativeai zhipuai python-dotenv requests qdarkstyle

      # Optionally run tests before building, controlled by the RUN_TESTS variable
      if ("$Env:RUN_TESTS" -eq "true") { python -m pytest }

      # Build the EXE using the PyInstaller spec (entry point: src/main.py)
      python build_exe.py

      # Rename the generated EXE to include the sequential release number
      $buildNumber = $Env:CI_PIPELINE_IID
      if (-not $buildNumber) { $buildNumber = "local" }
      Write-Host "Release number: $buildNumber"

      $distDir = "dist"
      $exePath = Join-Path $distDir "Digital Workshop.exe"
      if (-not (Test-Path $exePath)) { Write-Error "EXE not found at $exePath" }

      $newExeName = "Digital Workshop-release-$buildNumber.exe"
      Rename-Item -Path $exePath -NewName $newExeName

      # Write release metadata alongside the artifacts
      $infoPath = Join-Path $distDir "build-info.txt"
      Set-Content -Path $infoPath -Value "Release: $buildNumber" -Encoding utf8
      Add-Content -Path $infoPath -Value "Commit: $Env:CI_COMMIT_SHA"
      Add-Content -Path $infoPath -Value "Pipeline: $Env:CI_PIPELINE_URL"

      # Attach per-release notes if available
      $notesSourceDir  = "release_notes"
      $notesSourceFile = "release-$buildNumber.txt"
      $notesSourcePath = Join-Path $notesSourceDir $notesSourceFile
      $notesTargetPath = Join-Path $distDir "release-notes.txt"

      if (Test-Path $notesSourcePath) {
          Write-Host "Including release notes from $notesSourcePath"
          Copy-Item -Path $notesSourcePath -Destination $notesTargetPath -Force
      } else {
          Write-Host "No specific release notes found for release $buildNumber"
          Set-Content -Path $notesTargetPath -Value "Release $buildNumber`r`nNo release notes provided." -Encoding utf8
      }
  artifacts:
    name: "digital-workshop-release-$CI_PIPELINE_IID"
    when: always
    expire_in: 1 year
    paths:
      - dist/

